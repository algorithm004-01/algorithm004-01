# NOTE

  

## Bit Operation

位运算：直接对整数在内存中的二进制位进行操作，处理速度很快

一元运算符：

- 左移 <<
- 右移 >> 
（新位补0，老位去除）
- 按位取反 ~

二元运算符：
- 按位或 |（有1则1）
- 按位与 &（有0则0）
- 按位异或 ^ （同0异1）

应用：

```
1. 交换两数：
c=a^b
a^c=b
b^c=a

2. x右边n位清零：x&(~0<<n)

3. 获取x第n位的值：(x>>n) & 1

4. 获取x第n位的幂值：x&(1<<(n-1))

5. 将第n位置为1：x!(1<<n)

6. 将第n位置为0：x&(~(1<<n))

7. 将x最高位至第n位（含）清零：x&((1<<n)-1)

8. 将x第n位之后清零：x&(~((1<<(n+1))-1))

9. 判断奇偶（判断二进制最后一位）：x&1==1（奇）x&1==0（偶）

10. 除法：x>>1 

11. 将**最低位的1**变为0：x&(x-1)

12. 只保留最低的1：x&-x

> 计算机运算中采用补码表示负数，因此-x是x取反再加1
```


## Bloom Filter

HashTable+链式存储：存储全部数据到内存空间

如果只需要一个判断是否在集合中的数据结构，则不需要存储数据本身。因此设计了Bloom Filter，用一个很长的二进制向量和一系列随机映射函数将元素对应到多个二进制位中，可以很高效地判断一个元素是否在一个集合中。它的空间效率和查询时间远超一般算法，但存在一定的误识别率，且删除困难。

查询测试元素时，只要有一位为0，则一定不在；但全为1，不一定在（因此Filter常用于快速查询的缓存，相当于在不存在时剪枝后续操作）。


## LRU Cache

采用的缓存替换策略：最近最少使用（Least Recently Use，即最新的元素放到最前），通常使用HashTable + DoubleEnd LinkedList实现，具有O(1)的查询、修改、更新效率

### 排序算法

1. 比较类排序：时间复杂度不能突破O(nlogn)：
- 交换：冒泡，快速
- 插入：简单插入、希尔
- 选择：简单选择、堆排序
- 归并：二路、多路

2. 非比较类排序：不通过比较来确定元素前后次序，可以突破下界，以线性时间完成
- 计数排序
- 桶排序
- 基数排序

> 准备面试时，重点看O(nlogn)的排序：快速、桶排、归并

初级排序O(n^2):
- Selection sort
    - 每次选择最小值放到数组起始位置
    - 找剩余元素最小值O(n)，需要找n次

- Insertion sort：
    - 对于未排序数据，在已排序列中从后往前扫描找位置插入，保持前子序列为有序（从前到后逐步构建）
    - 寻找插入位置O(n)，内层循环挪动O(n)
- Bubble sort：
    - 嵌套循环，每次查看相邻元素，如果逆序则交换
    - 循环一次可以冒好一个元素

高级排序O(nlong)
- 快速排序
    - 使用分治法，递归地把小于基准值元素的子数列和大于基准值元素的子数列排序
    - 数组取标杆pivot（中间、左右均可），将小（大）于pivot的元素都放在pivot左（右）边，依次递归对左右子数组进行快速排序
    
- 归并排序
    - 采用分治法，把长度为n的输入序列分成两个长度为n/2的子序列；
    - 对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列
    
- 堆排序
    - 堆是一颗每个结点的值都大于等于或小于等于其左右孩子结点值的完全二叉树，存储为数组，从1开始存储数据，i的左子节点为2*i，右子节点为2*i+1
    - 将元素组织为最大或最小堆(O(n))，将堆顶元素与堆数组的末尾元素进行交换，递归地调整堆(O(logn))，将堆顶元素再与末尾元素进行交换
    - 将元素取出，得到有序序列
    - 插入/删除O(nlogn)，取最值O(1)

特殊排序O(n)
- 计数排序
- 桶排序
- 基数排序