# NOTE

单词搜索 2 用 Tire 树方式实现的时间复杂度是O(n*k) (k表示单词的平均长度)

双向BFS模板
```python
#!/usr/bin/env python3
def BFS(graph,start,end):
  start_queue = []
  end_queue = []
  start_queue.append([start])
  end_queue.append([end])
  
  while start_queue:
    node = start_queue.pop()
    visited.add(node)

    process(node)

    nodes = generate_related_nodes(node)
    queue.push(nodes)
    if (len(start_queue) > len(end_queue)):
      start_queue,end_queue = end_queue,start_queue
    ...
```

1. 字典树和并查集
    1. 字典树 Trie
        1. 基本结构:字典树，即 Trie 树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎用于文本词频统计。优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高
        2. 基本性质:
            1. 节点本身不存完整单词
            2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
            3. 每个节点的所有子节点路径代表的字符都不相同
    2. 并查集 Union-Find
        1. 并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题
        2. 使用场景:组团, 配对问题

2. 高级搜索
    1. 剪枝
        1. 将复杂的决策树进行简化的过程称为剪枝，目的是去掉一些节点，包括叶节点和中间节点
    2. 双向 BFS (Two-ended Breadth First Search)
        1. 如果已经知道搜索的开始状态和结束状态，要找一个满足某种条件的一条路径（常见是最短路径），为了避免无谓的“组合爆炸”产生，就可以采取双向广度优先搜索，也就是从开始状态和结束状态同时开始搜索，一个向前，一个向后
    3. 启发式搜索/优先级搜索 Heuuristic Search(A*)
        1. 利用问题拥有的启发信息来引导搜索，达到减少搜索范围、降低问题复杂度的目的

3. 红黑树和AVL树
    1. 平衡二叉搜索树
        1. 保证性能的关键是左右子树节点平衡, 保证二叉搜索树的查询速度只与节点高度相关, 和节点数无关
    2. AVL树
        1. 自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1
    3. 红黑树 Red-black tree
        1. 红黑树是一种近乎平衡的二叉搜索树，它能够确保任何一个节点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树
        2. 每个节点要么是红色，要么是黑色, 根节点是黑色, 每个叶节点(空节点)是黑色的
        3. 不能有相邻接的两个红色节点
        4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
    4. 对比
        1. AVL树查询比红黑树更快，因为AVL树是更加严格的平衡
        2. 红黑树插入和删除比AVL树更快, 因为AVL树的旋转操作会更多
        3. AVL树要在每个节点存额外的信息(平衡因素和高度），红黑树只要一个bit来存0,1表示黑或红
        4. 查询操作多推荐用AVL树,否则选择红黑树