#### 字典树和并查集

利用Trie树算法统计单词出现的次数的时间复杂度如下：
用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平均长度)


爬楼梯、硬币问题 、兔子繁育->斐波拉契数列


朋友圈：解法

1.DFS

2.BFS

3.并查集（Disjoint set）

a.N-->各自独立集合

b.遍历好友关系矩阵M[i][j]=>合并

c.看有多少孤立的集合



#### 高级搜索

- 剪枝
- 双向BFS
- 启发式搜索


初级搜索
1.朴素搜索
2.优化方式：不重复（fibonacci）、剪枝（生成括号问题）
3.搜索方向：BFS、DFS

- 回溯法

[双向BFS](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode/)
算法

算法与之前描述的标准广搜方法相类似。

唯一的不同是我们从两个节点同时开始搜索，同时搜索的结束条件也有所变化。

我们现在有两个访问数组，分别记录从对应的起点是否已经访问了该节点。

如果我们发现一个节点被两个搜索同时访问，就结束搜索过程。因为我们找到了双向搜索的交点。过程如同从中间相遇而不是沿着搜索路径一直走。

双向搜索的结束条件是找到一个单词被两边搜索都访问过了。

最短变换序列的长度就是中间节点在两边的层次之和。因此，我们可以在访问数组中记录节点的层次。

#### AVL树和红黑树的实现和特性


- AVL Tree 平衡二叉搜索树
- Red Black Tree 近似平衡的二叉搜索树
