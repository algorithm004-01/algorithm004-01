# 【701-week1】第一周学习总结

## 数组

特点：

- 是一种线性数据结构，用连续的存储空间存储相同类型数据；
- 下标从 `0` 开始；
- 支持 `随机访问`，根据下标随机访问的时间复杂度为 O(1)；
- 低效的 `插入` 和 `删除`；
- 警惕 `越界` 访问问题；
- 基于数组类型的 `容器类型` 支持动态扩容；

复杂度分析：
- 时间复杂度：平均的时间复杂度为 O(n) 
    - prepend/append：O(1)
    - lookup： 按下标访问是 O(1)
    - insert：最好是 O(1)，最坏是 O(n)，平均是 O(n)
    - delete：最好是 O(1)，最坏是 O(n)，平均是 O(n)
- 空间复杂度：O(1)

## 链表

特点：

- 常用于插入/删除操作较频繁的场景（空间换时间）
- 元素数量未知
- 缓存机制

复杂度分析：

- 时间复杂度
    - prpend：O(1)
    - append：O(1)
    - lookup：O(n)
    - insert：O(1)
    - delete：O(1)
- 空间复杂度：O(1)

实现思路：

- 理解指针或引用的含义
- 警惕指针丢失和内存泄漏
- 利用 `哨兵` 简化实现难度
- 重点留意边界条件
- 举例画图，辅助思考
- 多写多练

常见操作：

- 单链表反转
- 链表中环的检测
- 两个有序链表的合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

工程应用：

- LRU Cache - Linked List
- Redis - Skip List

### 单链表

### 双链表

### 循环链表

### 跳表

通过为链表添加 `有序索引` 的方式解决传统链表的 `低效查找问题`，以 `空间换时间`

- 在跳表中查询任意数据的时间复杂度是 O(logn)
- 空间复杂度是 O(n)


## 总结

数组是一种简单的 `线性` 数据结构，在内存中是一段只能存储 `同种数据类型` 的 `连续的内存空间`。其原理和实现思路是通过提前开辟好一段合适大小的内存空间，方便数据 `按下标方式` 能够进行快速查找。为了解决数组低效的插入和删除操作，链表应运而生，其在内存中是 `非连续` 的，通过 `指针` 方式来进行 `动态扩容`，这样一来，和数组相比，对应的插入和删除操作就非常高效，只需要移动对应结点的指针指向即可。基于此种数据结构衍生的数据结构类型还有 `循环链表`、`双链表`、`调表`。其中跳表是为了解决传统链表结构中低效的查询操作，所以其对应的实现思路是通过在原始链表的基础上建立 `n 级有序索引` 的方式来进行快速查找，是一种 `以空间换时间` 的解决方法。

数组、链表、跳表的复杂度如下表所示：

|       | 时间复杂度 | 空间复杂度 |
| :----:|  :----:   |  :----:   |
| 数组 | 插入&删除 O(n); 查找 O(1) | O(1) |
| 链表 | 插入&删除 O(1); 查找 O(n) | O(1) |
| 跳表 |  查找 O(logn) |  O(n) |

## 栈 & 队列

- stack：FILO，add&del：O(1),find：O(n)
- queue：FIFO，add&del：O(1),find：O(n)

## 双端队列

- 两端都可以进出的 Queue
- add&del: O(1)

## 优先队列

- 插入操作：O(1)
- 取出操作：O(logN) - 按照元素的优先级取出
- 底层具体实现的数据结构较为多样和复杂：heap，bst，treap

## 总结

`栈(FILO)` 和 `队列(FIFO)` 依然是 `线性` 的数据结构，这两种数据结构只允许同时在一端进行插入/删除操作，时间复杂度是 O(1)，实际工程中基于前两种数据结构又衍生出了 双端队列，该种类型的队列允许在两端进行插入/删除操作，时间复杂度为 O(1)；此外，基于此有产生了 优先队列，这种数据结构通过为对应结点设置优先级的方式来进行级别控制，在实际工程应用中较为广泛，例如会员系统的设计。

## 源码解析 - C# 版

[Stack](https://source.dot.net/#System.Collections.NonGeneric/System/Collections/Stack.cs,6acda10c5f8b128e)

> 通过查看源码得知，`Stack` 是采用 `array` 这种数据类型来进行相关操作，初始大小为 `10` 个单位长度。入栈操作为 `push`，函数内部直接对目标数组进行增加元素操作，期间会对数组长度进行安全检查；出栈操作为 `Pop`，函数内部直接对目标数组进行最后下标访问，返回该元素，并将数组中对应元素置空；查找操作为 `Peek`，该操作只会返回数组末尾元素对应的值，并不会对该数字进行任何修改。上述三种操作对应的时间复杂度均为 `O(1)`；`Contains` 方法为查找目标元素是否存在，其内部采用 while 循环的方式进行查找，时间复杂度为 `O(n)`。此外，Stack 本身是 `非线程安全的`, 所以 .NET 也提供了线程安全类型的版本 `SyncStack`。

[Deque](https://source.dot.net/#System.Threading.Channels/System/Collections/Generic/Deque.cs,8efc3f793e2f3a69)

> 通过查看源码得知，`Deque` 是采用 `array` 这种数据类型来进行相关操作，初始状态为 `0` 个单位长度，入队操作为 `EnqueueTail`，函数内部直接对目标数组进行增加元素操作，期间也会对数组进行动态扩容；出队操作为 `DequeueHead` 和 `DequeueTail`；这几种操作方式都相对简单，对应的时间复杂度均为 `O(1)`。此外，由于官方并未提供查找接口，所以我们只能通过 `GetEnumerator` 方式来进行查找，其内部采用 while 循环方式转为为 `list` 并返回，其对应的时间复杂度为 `O(n)`。

[PriorityQueue](https://source.dot.net/#WindowsBase/MS/Internal/PriorityQueue.cs,8017d5f6bed3a97e)

> 通过查看源码得知，`PriorityQueue` 内部采用了一个有序列表 `SortedList<int, PriorityChain<T>>` 和一个缓存栈 `Stack<PriorityChain<T>>` 来进行组合管理，有序列表是存着当前的所有数据，考虑到优先队列中数据优先级的修改频繁，将每次入队出队的数据都缓存到缓存栈中一份，避免对象的频繁创建，其中缓存栈的初始大小为 `10` 个单位长度；入队操作为 `Enqueue`，函数内部会往有序列表中添加元素（移动指针方式），同时会在缓存栈中进行出栈操作；出队操作为 `Peek`，该操作会将有序列表中的最后一个元素移除并返回；删除操作为 `RemoveItem`，函数内部会首先对有序列表中的对应元素执行删除操作，同时会将缓存栈执行入栈操作，将删除的目标数据加入到缓存栈中。




