# NOTE

## 用新API改写Deque代码

``` java
Deque<String> deque = new LinkedList<String>();

        deque.addFirst("a");
        deque.addFirst("b");
        deque.addLast("c");

        System.out.println(deque);

        String str = deque.peekFirst();
        System.out.println(str);
        System.out.println(deque);

        while(deque.size() > 0) {
            System.out.println(deque.removeFirst());
        }
        System.out.println(deque);
```

## Queue 的源码分析
底层使用链表实现，成员变量为头指针first，尾指针last和一个用来记录队列长度的 int 值 n。
### 主要方法实现
* isEmpty() - 头指针是否为null
* size() - 队列长度即 n 的值
* peek() - 不为空的话返回head对应的元素，为空的话抛出异常
* enqueue(item) - 在尾部插入item操作，增加队列长度 n++
* dequeue() - 在头部进行删除item操作，减少队列长度 n--

## Priority Queue 的源码分析
底层使用平衡二叉堆来实现，二叉堆是一颗完全二叉树或者近似二叉树。当父节点的键值总是大于或等于任何一个子节点的键值时为“最大堆”。当父节点的键值总是小于或等于任何一个子节点的键值时为“最小堆”。
Priority Queue使用的正是最小堆，堆的底层实现是数组。数组第n个元素的的两个子节点分别为第2*n+1和2*(n+1)个元素。
加入的元素都需要实现Comparator，优先级的比较正是使用compareTo方法实现的。

### 主要方法实现
* add()/offer() - 在数组尾部插入新元素，执行siftUp操作：如果其值小于堆父节点的话，与父节点交换。重复该操作，直至其值大于等于父节点或者到了根节点。size ++。
* peek() - 返回第0个元素，如果数组为空返回null
* poll() - 返回第0个元素，执行siftDown操作：将最后一个元素填在堆顶即第0个元素，然后不然和子节点比较调整位置。size --。
* size() - 返回内部成员变量size的值。size随着add()和poll()的操作增加或减少

## 学习总结
### 数组、链表和跳表
数组和链表都是最基本的数据结构，很多复杂数据结构就是基于他们实现的。
数组的底层实际上使用的是计算机内存空间中开辟的一段连续的地址，而链表是一组连在一起的节点Node，每个Node都有一个value值和一个next指针，next指针指向下一个元素。由于底层实现的不同他们在随机访问，插入和删除操作上面有很大的不同，我们在使用的时候要根据各自的特性来挑选最适合的。他们进行基本操作的时间复杂度分别为：
数组：
* 随机访问：O(1)，直接访问内存地址
* 插入：O(n)，需要将插入位置之后的元素向后移动
* 删除：O(n)，需要将删除位置之后的元素向前移动

链表：
* 随机访问：O(n)，需要遍历节点来搜索值
* 插入：O(1)，直接操作next指针
* 删除：O(1)，直接操作next指针

链表插入操作代码示例：
```
newNode->next = node->next
node->next = newNode
```
链表删除操作代码示例：
```
preNode->next = delNode->next
delNode->next = null
```

跳表可以认为是优化了随机访问速度的链表，在算法中优化时间复杂度的核心思想有两个：
1. 升维
2. 空间换时间

跳表在链表的基础上额外增加了一系列索引来优化访问速度。添加索引的规律是第n级索引的每两个索引的跨度是2的n次方，即第一级索引每隔2个节点一个索引，第二级每隔4个节点一个索引,......。因此有n个元素就有logn级索引，第k级索引的节点数为 n / (2^k)。
跳表查询的时间复杂度与索引的高度相关为O(logn)，在实际使用中插入和删除操作会导致重新编排索引，因此它的复杂度也为O(logn)。
由于使用的额外的索引，跳表的空间复杂度为O(n)。

### 栈、队列、优先队列和双端队列
栈和队列最大的区别就在于元素的进出方式，栈是先入后出即FILO，队列为先入先出即FIFO。他们的添加和删除复杂度都为O(1)。
将队列优化一下，使得两端都可以进行添加删除操作的话就变成了双端队列(Deque: Double-End Queue)，由于两端可以进行操作，双端队列可以用来代替栈。
如果对队列的元素取出做一个限制，按照优先级来操作，那么就是优先级队列了。由于取出操作需要对元素优先级进行比较，所以其取出的时间复杂度为O(logN)，插入依然是O(1)。优先队列的底层实现的数据结构比较多样和复杂，常见的有heap, bst, treap。Java中使用的是heap。

在算法题中，栈和队列可以用来解决特定的问题：
* 栈 - 最近相关性问题
* 队列 - 先来后到问题