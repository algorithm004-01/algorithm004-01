# 解题思路回顾与总结
本周完成了8道作业题的练习，主要涉及了数组、链表、队列相关的题目。获得了以下几个解题套路
- 双指针
    - 双指针碰撞
    - 双指针左右夹逼
    - 快慢指针
- 数组下标的计算方式
    - 索引循环实现环形队列（在循环双端队列的实现中体现）
    - 索引步长增长，构成环状旋转
- 链表的哨兵模式简化代码（在合并有序链表的实现中体现）

# 学习总结
- 解题基本思路
    - 暴力解法
    - 从基本问题入手，化繁为简
    - 寻找最近重复子问题进行泛化求解

- 抽象数据结构
    - 栈，通过封装数组或链表的一个访问受限的线性数据结构，提供「先入后出」的特性
    - 队列，通过封装数组或链表的一个访问受限的线性数据结构，提供「先进先出」的特性
        - 双端队列（栈和队列结合体），可以在两端进行入队、出队操作。可以视为栈、队列使用
        - 优先队列，在Java中放入优先队列的元素需要实现接口「Comparator」来定义优先级大小，实现了一个根据优先级大小取出元素的抽象数据结构。底层可以由heap、bst实现

- 源码分析
    - Queue
    ```java
    public interface Queue<E> extends Collection<E> {
        // 从尾部入队一个元素，当队列满时抛出异常
        boolean add(E e);
        
        // 从尾部入队一个元素, 队列满时返回false
        boolean offer(E e);

        // 从头部出队一个元素，当队列为空时抛出异常
        E remove();

        // 从头部出队一个元素，当队列为空时返回null
        E poll();

        // 仅查看头部元素，不出队，当队列为空时抛出异常
        E element();

        // 仅查看头部元素, 不出队，当队列为空时返回null
        E peek();
    }
    ```
    - PriorityQueue
    底层使用二叉堆来存储元素，每个元素之间存在某种大小比较的定义：① 初始化PriorityQueue时，传入Comparator；② 每个元素实现了Comparable接口；在入队时，利用二叉堆的「堆化逻辑」将优先级最高的元素放到了队列的队首位置。在出队时可以通过O(1)的时间复杂度进行出队
