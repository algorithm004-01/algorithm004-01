1. 
    本来对queue持有很清晰的印象，但是随着接触的越来越多，反倒是越模糊
    
    首先，在我的死记硬背中，队列属于线性结构，但是至于是连续性还是非连续性，这个就要另当别论了。因为接口只规范功能，不限制属性。而属性才是判断线性还是非线性的依据。下面来分析一下：
        
            Queue是一个接口，其子接口有Deque，（注意是有且不仅有的关系，莫要混淆）
            Queue有自己的实现类，比如ArrayQueue,PriorityQueue,TaskQueue等等，他们内部是持有一个数组容器进行操作的，所以这个队列算是连续性线性结构。
            当然了，Queue有别的子接口的实现类，比如接口BlockingQueue的实现类LinkedBlockingDeque等等,这个实现类内部则持有一个结点类型的数据结构，那么这时候他就是非连续的线性（一维）结构
            至于别的案例，有时间自己仔细看看，会发现天下大同
    
    queue的方法：
        add
        offer
        remove
        poll
        element
        peek

2. 
    PriorityQueue
        集成Queue,所以queue该有的方法他也有。
        但是属性里面，多了一个很特殊的Comparator,也因此衍生出了很多函数，都用于和优先级有关。
        和Queue不同的是，他是一个类，集成了AbstractQueue。
        DelayQueue的操作就是基于PriorityQueue的。
        
        PriorityBlockingQueue 持有PriorityQueue的引用，同时内部也含有一个Comparator.
        这个以后在研究
        
        
3. 写完1,2后，我开始补写代码作业，设计循环双端队列。
    初始的时候，很迷惑，因为对jdk自带的Deque了解的没有那么彻底，导致我的思路一致卡在了怎么设计一个和Deque一样的数据结构。这时候的思想还停留在模仿造车，但是模仿的前提是要对模仿对象足够了解。
    自己也看了Deque的源码，对每个函数都能理解，但是真的要融会贯通，做到能跳出当局者的角度去思考这样的高度，还差火候。
    
    后来很纠结的时候，开始多次读题，终于发现自己不小心进了牛角尖，原来我不需要去照着Deque写，我只需要满足题目的条件就可以，对着题目的案例很容易就能理解循环双端这个结构。同理，学习jdk自带的deque的时候，也要用demo带入学习i即可。
    
    按照题目的意思，他们来不同的在于。jdk自带的支持grow，而本题目不需要支持。对着题目给的案例，去写，就会觉得思路很清晰。
      
        
        
        
        