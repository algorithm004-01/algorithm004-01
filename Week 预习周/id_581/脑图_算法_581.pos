{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"算法","leftChildren":[{"id":"89ac0efc4369","title":"分治法","children":[{"id":"cd456d62434c","title":"定义","children":[{"id":"5c43b7ce0529","title":"通过将大问题拆分为多个子问题，求解子问题并将解集合并为原问题的解","children":[],"parent":"cd456d62434c"}],"parent":"89ac0efc4369"},{"id":"9ea6410343a6","title":"运行时间计算","children":[{"id":"437923ff3761","title":"一般式","children":[{"id":"795ad09397b4","title":"<ul><li>T(n) = aT(n / b) + f(n) f(n)∈Θ(n^d) d &gt; 0 T(n)表示解决问题所需要的时间，f(n)是将子问题解拼成最终解的时间<br></li></ul>","children":[],"parent":"437923ff3761"}],"parent":"9ea6410343a6"},{"id":"f0ac0c3be059","title":"主定理","children":[{"id":"66da38406b6a","title":"if a &lt; b^d, T(n)∈Θ(n^d)","children":[],"parent":"f0ac0c3be059"},{"id":"0f6001a9d22d","title":"if a = b^d, T(n)∈Θ(n^d log n)","children":[],"parent":"f0ac0c3be059"},{"id":"078d0e37a5db","title":"if a &gt; b^d, T(n)∈Θ(n^(logb(a)))","children":[],"parent":"f0ac0c3be059"}],"parent":"9ea6410343a6"}],"parent":"89ac0efc4369"}],"parent":"root"},{"id":"cd3ef14ef1ac","title":"归并排序","parent":"root","children":[{"id":"b367faf996b7","title":"T(n) = 2 * T(n / 2) + f(n)","parent":"cd3ef14ef1ac","children":[]},{"id":"5383af048ffc","title":"主定理：T(n) ∈ nlogn","parent":"cd3ef14ef1ac","children":[]}]},{"id":"a766f4f0bb6e","title":"快速排序","parent":"root","children":[{"id":"b3ed31a47625","title":"最差：当序列已经有序时","parent":"a766f4f0bb6e","children":[]},{"id":"446c4592cb80","title":"最好：当序列恰好二分后都排好序","parent":"a766f4f0bb6e","children":[]},{"id":"d433e74d9ff1","title":"最差: T(n) = T(n - 1) + Θ(n)，T(n)∈Θ(n^2)","parent":"a766f4f0bb6e","children":[]},{"id":"2567c69d2d57","title":"最好: T(n) = 2 * T(n / 2) + Θ(n), T(n)∈Θ(nlogn)","parent":"a766f4f0bb6e","children":[]},{"id":"1c3fe28d8256","title":"平均: T(n) ∈ Θ(nlogn)","parent":"a766f4f0bb6e","children":[]}]},{"id":"23451a236974","title":"寻找关节点<br>Articulation<br>","parent":"root","children":[{"id":"a416fc4cb8c5","title":"关节点定义","parent":"23451a236974","children":[{"id":"4c581bf990fa","title":"删除该点会使得当前图不再连通(生成两棵树)","parent":"a416fc4cb8c5","children":[]}]},{"id":"127011253584","title":"步骤","children":[{"id":"f6b4413968e6","title":"1. 使用DFS构成DFS树，记录树边以及回边<br>回边：深度搜索时遇到非直接父节点的已遍历节点<br><br>","children":[],"parent":"127011253584"},{"id":"3b27ace82c0a","title":"2.&nbsp;<br>* DFS树中，叶子节点永远不会是关节点<br>* 当根节点有两棵以上子树时，根节点才是关节点<br>* 内部节点中，假如A节点的任何子节点B与A节点的<br>任何祖先C之间存在回边，则A不是关节点<br>","children":[],"parent":"127011253584"}],"parent":"23451a236974"}]},{"id":"06349cc4a7b8","title":"AVL树","children":[{"id":"0eedfbc43c11","title":"定义","children":[{"id":"34c713314f61","title":"AVL树是一棵二叉树，节点上左右子树的高度差称为该节点的平衡因子；<br>AVL树中每个节点的平衡因子均不超过1；<br>空子树的高度为-1","children":[],"parent":"0eedfbc43c11"}],"parent":"06349cc4a7b8"},{"id":"06c303946537","title":"顶点增删导致不平衡<br>四种处理方式","children":[{"id":"3703abf342c1","title":"1. 单左旋","children":[],"parent":"06c303946537"},{"id":"85b542a956f8","title":"2. 单右旋","children":[],"parent":"06c303946537"},{"id":"417b955cb02c","title":"3. 双左右旋","children":[],"parent":"06c303946537"},{"id":"631608cb3f7c","title":"4. 双右左旋","parent":"06c303946537","children":[]}],"parent":"06349cc4a7b8"},{"id":"55825b3101ac","title":"高度判定","children":[{"id":"9eef3fd58d70","title":"某一边的子树高度是从0开始计算的<br>比如左子树只有一个节点，则左子树高度为0<br>","children":[],"parent":"55825b3101ac"},{"id":"53fd451dc3f9","title":"高度差为左子树高度-右子树高度","parent":"55825b3101ac","children":[]}],"parent":"06349cc4a7b8"}],"parent":"root"},{"id":"cf0a4f46b461","title":"堆与优先队列","children":[{"id":"8b1b8fd864de","title":"定义","parent":"cf0a4f46b461","children":[{"id":"aa5154305d35","title":"1. 堆是一棵完全二叉树<br>2. 堆的元素之间只有上下关系，不保证左右关系<br>3. 上面元素大的称为最大堆，反之为最小堆<br>","children":[],"parent":"8b1b8fd864de"}]},{"id":"79c06f5425e6","title":"创建","parent":"cf0a4f46b461","children":[{"id":"6225ef8d4296","title":"1. 自顶向下O(nlogn)","parent":"79c06f5425e6","children":[{"id":"16f7f53ce23c","title":"向堆中插入新元素，然后将新元素往上浮","children":[],"parent":"6225ef8d4296"}]},{"id":"a0f11fe2b438","title":"2. 自底向上O(n)","parent":"79c06f5425e6","children":[{"id":"d7857fefaf33","title":"对已经生成的未排序堆，检查每个中间节点以及其子树是否满足堆要求","children":[],"parent":"a0f11fe2b438"}]}]}],"parent":"root"},{"id":"dd4ecc96e08b","title":"爬山，Best-first，分支定界","parent":"root","children":[{"id":"31b5f26ede02","title":"爬山是按照当前活动节点梯度进行深度优先搜索解","children":[],"parent":"dd4ecc96e08b"},{"id":"cce23fc50c8b","title":"Best-first是按照所有可能的活动节点中梯度最大的进行广度优先搜索解","children":[],"parent":"dd4ecc96e08b"}]}],"structure":"mind_right","root":true,"theme":"theme3","children":[{"id":"0d0174ed6bce","title":"什么是算法","parent":"root","children":[{"id":"1176db06e731","title":"有限性","parent":"0d0174ed6bce","children":[{"id":"3d17a42692db","title":"算法需要在有限步骤中完成问题","parent":"1176db06e731","children":[]}]},{"id":"941d8f0e4245","title":"定义","parent":"0d0174ed6bce","children":[{"id":"e6d138fbff9a","title":"一个算法有清晰的定义","parent":"941d8f0e4245","children":[]}]},{"id":"1eb3099c27a6","title":"输入","parent":"0d0174ed6bce","children":[]},{"id":"55299ae591ee","title":"输出","parent":"0d0174ed6bce","children":[]},{"id":"252526d8b8d4","title":"效率","parent":"0d0174ed6bce","children":[]}]},{"id":"9b96493cdd04","title":"算法分析","parent":"root","children":[{"id":"17fe63a33483","title":"时间效率","children":[{"id":"7c9e149bdb68","title":"理论分析","children":[{"id":"e1f16486c32d","title":"基本操作与输入规模的乘积 T(n) ≈ op * C(n)","children":[],"parent":"7c9e149bdb68","collapsed":false},{"id":"3c32b8fb1b71","title":"基本操作：直接影响算法运行时间的操作","parent":"7c9e149bdb68","children":[]},{"id":"1f03f5828ad6","title":"输入规模：","parent":"7c9e149bdb68","children":[{"id":"bd6bcf24753e","title":"排序：排序元素数量","parent":"1f03f5828ad6","children":[]},{"id":"cbeaea3ce7be","title":"矩阵相乘： 矩阵元素数量","parent":"1f03f5828ad6","children":[]},{"id":"d2349f6785b2","title":"图：边/点","parent":"1f03f5828ad6","children":[]}]}],"parent":"17fe63a33483"}],"parent":"9b96493cdd04"},{"id":"bfddea3c1105","title":"空间效率","children":[],"parent":"9b96493cdd04"},{"id":"6d20e750487a","title":"优化极限","children":[{"id":"0eb8e07f256b","title":"大O","parent":"6d20e750487a","children":[{"id":"fb273a8725ca","title":"f(n)∈O(g(n)): 意味着fn的增长速度不会超过(&lt;=)gn&nbsp;","parent":"0eb8e07f256b","children":[]}]},{"id":"aa66ae0124ac","title":"小o","parent":"6d20e750487a","children":[{"id":"ec14371c3a7b","title":"与大O相似，只是此时fn &lt; gn 没有等于号","parent":"aa66ae0124ac","children":[]}]},{"id":"8763ffabeb02","title":"大Θ","parent":"6d20e750487a","children":[{"id":"c326215f7cea","title":"f(n)∈Θ(g(n)): 意味着fn增长与gn近似","parent":"8763ffabeb02","children":[]}]},{"id":"4a81331ac328","title":"大Ω","parent":"6d20e750487a","children":[{"id":"11ffa4a62865","title":"f(n)∈Ω(g(n)): 意味着fn增长要比gn快(&gt;=)","parent":"4a81331ac328","children":[]}]},{"id":"8988432e26e5","title":"小Ω","parent":"6d20e750487a","children":[{"id":"79e8c8574a75","title":"与大Ω类似，只是此时fn &gt; gn 没有等于号","children":[],"parent":"8988432e26e5"}]},{"id":"668ade050419","title":"规则","parent":"6d20e750487a","children":[{"id":"9f6670cd693e","title":"f1n∈O(g1n)且g1n∈O(g2n)，则f1n∈O(g2n)","parent":"668ade050419","children":[]},{"id":"5c89ce22049b","title":"f1n∈O(g1n)且f2n∈O(g2n)，则f1n + f2n∈O(max{g1n, g2n})","parent":"668ade050419","children":[]}]},{"id":"bae1276155e4","title":"log(n) &lt; n^a &lt; a^n &lt; n! &lt; n^n","parent":"6d20e750487a","children":[]},{"id":"c1b7df9f7db2","title":"注意对递归算法的运行时估算——数列递推公式求通项公式","children":[],"parent":"6d20e750487a"}],"parent":"9b96493cdd04"}]},{"id":"7d5985e321e4","title":"红黑树","parent":"root","children":[{"id":"5edbe95493ff","title":"定义","parent":"7d5985e321e4","children":[{"id":"4d405e40b4eb","title":"红黑树是一棵拥有以下特性的二叉搜索树：<br>1. 每个节点要么是红的，要么是黑的<br>2. 根节点一定是黑的<br>3. 每个叶子节点都是为NIL的黑色的节点<br>4. 假如一个节点是红色的，则该节点的直接子节点以及直接父节点必须是黑的<br>5. 每个节点为起点到后代叶子节点所经过的所有路径，包含的黑色节点(不包括起点)数量是相同的<br>&nbsp; &nbsp; (这也被称为黑树高度)<br>","parent":"5edbe95493ff","children":[]}]},{"id":"ae7868e16375","title":"3种插入修正方式","children":[],"parent":"7d5985e321e4"}]},{"id":"e5ab32a6f0b8","title":"Knuth-Morris-Pratt<br>KMP","children":[{"id":"f1d968f66648","title":"算法过程","parent":"e5ab32a6f0b8","children":[{"id":"6ea39f102d35","title":"该算法预先生成一张偏移表<br>当出现不匹配情况时，根据偏移表决定下一次匹配的开始位置<br>","parent":"f1d968f66648","children":[]}]},{"id":"4997ce825272","title":"偏移表-Π","parent":"e5ab32a6f0b8","children":[{"id":"a245b0a25373","title":"该表中记录了每个字符位置出现不匹配时<br>前面已经匹配成功的字符串中有多少个字符可以使用<br>","parent":"4997ce825272","children":[]},{"id":"667b39a4ecc4","title":"假设字符串ababa","parent":"4997ce825272","children":[{"id":"167df5ba634c","title":"abab已经匹配成功","children":[],"parent":"667b39a4ecc4"},{"id":"91e05cd1b114","title":"则前缀aba串也可以看作是后缀aba，故可以免去校验3个字符","children":[],"parent":"667b39a4ecc4"}]}]},{"id":"66c704c4a094","title":"匹配过程","parent":"e5ab32a6f0b8","children":[{"id":"8f71e4154439","title":"匹配串与被匹配串从左往右开始匹配<br>匹配串初始偏移值为0<br>若校验了n个字符，其中n-1个字符不匹配<br>则匹配串下次的偏移值为S = S + (n - Π(n))<br>","parent":"66c704c4a094","children":[]}]}],"parent":"root"},{"id":"f429a1d9e021","title":"BM算法","parent":"root","children":[{"id":"184ebc286c5e","title":"定义","parent":"f429a1d9e021","children":[{"id":"241c8f7b7fa6","title":"根据坏字符表和好后缀表的结果，计算两者各自的偏移值取最大偏移","parent":"184ebc286c5e","children":[]}]},{"id":"6d2786864a57","title":"坏字符","parent":"f429a1d9e021","children":[]},{"id":"56c8ea05780b","title":"好后缀","parent":"f429a1d9e021","children":[]}]},{"id":"facb5ade9aea","title":"扩展哈希","parent":"root","children":[]},{"id":"750ec7ff8c60","title":"回溯","parent":"root","children":[{"id":"4f81491b1c59","title":"利用深度优先的方法，通过逐步修改状态，逼近解空间，一旦逼近过程中出现不可能的情况，则马上返回","parent":"750ec7ff8c60","children":[]}]}]}},"meta":{"id":"","member":"","exportTime":"2019-10-13 23:33:15","diagramInfo":{"category":"","title":"","created":"","modified":"","creator":""},"type":"ProcessOn Schema File","version":"1.0"}}