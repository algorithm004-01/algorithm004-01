# NOTE

  

## Week8-19-动态规划

### 基础DP

大部分动态规划最简化的程序往往是动态递推，利用数学归纳法从之前的DP状态循环递推到最终的解。

1. DP状态的定义
2. 状态转移方程
3. 最终解位置

动态规划和递归或分治没有本质区别，共性为找重复子问题，关键看有无最优子结构，动规中途可以淘汰次优解

dp[i][j] = min(dp[i-1][j], dp[i-1][j] + A[i][j])


### 高级DP

1. 状态拥有更多的维度
2. 状态方程更为复杂
3. 本质考察逻辑思维和数学能力等内功

关键需要确定：

1. 维度（定义、压缩）
2. 状态转移方程
3. 初始化和边界条件

> 面试中状态定义比较重要，竞赛中递归方程会比较难

> 多练多思考，提升数学能力和抽象思维

#### 实例

##### 9. 股票买卖（121）

三维DP搞定股票买卖系列：


##### 10. Edit Distance（72）


BFS或双向BFS

字符串变换：（一般使用）二维数组定义DP状态

> 隐含条件：两个字符串的长度在变换中相互靠近；增加和删除是对等的操作

dp[i][j]: word1[0:i]与word[0:j]之间的编辑距离

w1[-1] == w[-1] ?

Y: dp[i][j] = dp[i-1, j-1]

N: min(dp[i-1, j-1] + 1, dp[i-1][j]+1, dp[i, j-1] + 1)

## 字符串算法

字符串可变语言：

C/C++, Ruby, PHP, Swift

字符串不可变语言：

Java, Python, C#, Javascript, Go

### DP+String

1. 编辑距离

dp[i][j] = dp[i-1][j-1] if w1[i]==w2[j] else min(dp[i-1][j-1], dp[i-1]][j], dp[i][j-1])+1

2. 最长公共子序列

dp[i][j] = dp[i-1][j-1] + 1 if s1[i] == s2[j] else max(dp[i-1][j], dp[i][j-1])

3. 最长公共子串

dp[j][j] = dp[i-1][j-1] + 1 if s1[i] == s2[j] else 0

4. 最长回文子序列

- 暴力枚举起点和终点，判断子串是否回文
- 枚举子串中心的一个字符（奇数长度）或中心两个（偶数长度），判断两边对称的字符长度
- DP：dp[i][j]=(dp[i+1][j-1] || (j-i)<2) if s[i]==s[j]

5. 正则表达式


6. 不同子序列

### 字符串匹配算法 （知道原理可以自己解释即可）

> 给定两个字符串，问其中一个字符串在另一个字符串中出现的起点

1. BrutalForce O(mn)

高级算法都是在暴力枚举的基础上进行优化

2. Rabin-Karp

用hash值先过滤掉不可能相同的子串起点；如果hash值相同，再逐个字符比较

但如果每次都是先取子串再调用系统hash进行计算的话，因hash函数会遍历子串，复杂度其实还是O(mn)

使用滑动窗口进行加速：O(1)来更新hash值，从而整体上平均达到O(n)的复杂度

3. KMP

找已匹配片段最大前缀和最大后缀的最长长度

insight：当知道在某个位置不匹配时，其实已经知道了前面能匹配的子串，可以利用已知匹配往后挪动