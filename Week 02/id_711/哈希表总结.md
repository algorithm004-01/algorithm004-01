# 哈希表总结

​				参考以下文章：

​					https://blog.csdn.net/qauchangqingwei/article/details/80914832

​					https://blog.csdn.net/chenhuajie123/article/details/9210529

​					https://blog.csdn.net/u011109881/article/details/80379505

## 一：哈希表（hash table）基本概念

1. 哈希表(Hash Table)也叫散列表，是根据关键码值（Key Value）而**直接进行访问的数据结构**。它通过把关键码值映射到哈希表中的一个位置来访问记录，以**加快查找的速度**。这个映射函数就做散列函数，存放记录的数组叫做散列表。

2.  以数据中每个元素的关键字K为自变量，通过散列函数H（k）计算出函数值，以该函数值作为一块**连续**存储空间的的单元地址，将该元素存储到函数值对应的单元中。

3. 哈希表存储的是键值对，其查找的时间复杂度与元素数量多少无关，哈希表在查找元素时是**通过计算哈希码值来定位元素的位置**从而直接访问元素的，因此，哈希表**查找的时间复杂度**为O（1）。

4. 装填因子 = （哈希表中的记录数） /  （哈希表的长度）

   装填因子是哈希表装满程度的标记因子。值越大，填入表中的数据元素越多，产生冲突的可能性越大。

## 二：常用的哈希构造方法

1. **直接寻址法**

   取关键字或者关键字的某个线性函数值作为哈希地址,即H(Key)=Key或者H(Key)=a*Key+b(a,b为整数),这种散列函数也叫做自身函数.如果H(Key)的哈希地址上已经有值了,那么就往下一个位置找,知道找到H(Key)的位置没有值了就把元素放进去.

2. **数字分析法**

   分析一组数据,比如一组员工的出生年月,这时我们发现出生年月的前几位数字一般都相同,因此,出现冲突的概率就会很大,但是我们发现年月日的后几位表示月份和具体日期的数字差别很大,如果利用后面的几位数字来构造散列地址,则冲突的几率则会明显降低.因此数字分析法就是找出数字的规律,尽可能利用这些数据来构造冲突几率较低的散列地址.

3. **平凡取中法**

   **取关键字平方后的中间几位作为散列地址**

4. **折叠法**

   折叠法即将关键字分割成位数相同的几部分,最后一部分位数可以不同,然后取这几部分的叠加和(注意:叠加和时去除进位)作为散列地址.数位叠加可以有移位叠加和间界叠加两种方法.移位叠加是将分割后的每一部分的最低位对齐,然后相加;间界叠加是从一端向另一端沿分割界来回折叠,然后对齐相加.

5. **随机数法**

   选择一个随机数,去关键字的随机值作为散列地址,通常用于关键字长度不同的场合.

6. **除留余数法**

   取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即H(Key)=Key MOD p,p<=m.不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选得不好，则很容易产生冲突。

## 三：哈希冲突

​	即不同key值产生相同的地址，H（key1）=H（key2）。不管hash函数设计的如何巧妙，总会有特殊的key导致hash	冲突，特别是对动态查找表来说。通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此	解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一	致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：

1. **开放定址法**

   1.1 **线性探测**

   ​	线性探测法的地址增量di = 1, 2, … , m-1，其中，i为探测次数。该方法一次探测下一个地址，知道有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。

   ​	线性探测容易产生“聚集”现象。当表中的第i、i+1、i+2的位置上已经存储某些关键字，则下一次哈希地址为i、i+1、i+2、i+3的关键字都将企图填入到i+3的位置上，这种多个哈希地址不同的关键字争夺同一个后继哈希地址的现象称为“聚集”。聚集对查找效率有很大影响。

   1.2 **二次探测**

   ​	二次探测法的地址增量序列为 di = 1^2， -1^2， 2^2， -2^2，… ， q^2, -q^2 (q <= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。

   1.3 **再哈希法**

   ​	这种方法是同时构造多个不同的哈希函数：

   ​        Hi=RH1（key），i=1，2,3，…,n.

   ​        当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。**这种方法不易产生聚集，但增加了计算时间**。

   1.4 **链地址法**

   ​	链地址法也成为拉链法。其基本思路是：将所有具有相同哈希地址的而不同关键字的数据元素连接到同一个单链表中。如果选定的哈希表长度为m，则可将哈希表定义为一个有m个头指针组成的指针数组T[0..m-1]，凡是哈希地址为i的数据元素，均以节点的形式插入到T[i]为头指针的单链表中。并且新的元素插入到链表的前端，这不仅因为方便，还因为经常发生这样的事实：新近插入的元素最优可能不久又被访问。

   ​	**链地址法特点**

   ​		(1) 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； 
   ​		(2) 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； 
   ​		(3) 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取		α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； 
   ​		(4) 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对		开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表		的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因		此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结		点。

   ![20160418101347575](C:\Users\asiaw\Desktop\20160418101347575.jpg)