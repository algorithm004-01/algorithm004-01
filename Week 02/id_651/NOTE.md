# NOTE
Week 2 总结

1.  哈希表： 散列表， 时间复杂度为O(1), 找到一个key即可映射到对应的存储空间，获取到值
    哈希函数： 通过函数的设计， 可以对key进行计算操作， 达到快速定位内存中key所对应的value
    映射： 和内存空间地址差不多， 一个key对应一个或多个value。
    集合： 有序的去重散列表， 内部会进行排序，去重。


2.  树： 链表的一种变形， 有根节点，左节点，右节点
    常见的数排序（主要是看根节点的位置判断是属于哪一种类型）
    -> 前序排序 ： 根左右
    -> 中序排序 ： 左根右  -> 二叉搜索树（有序的中序排序, 结果一定是按大小排好序的）
    -> 后序排序 ： 左右根
    图：在树的基础上，加上有环链表的一种变形

3.  递归 : 自己调用自己， 本质上是维护一个栈， 将不需要先执行的推到栈底，需要先执行的推到栈顶。
    递归函数的模板：
        1. 结束条件 -> 即是准备开始弹出栈顶元素的时候
        2. 当前层逻辑 -> 处理当前层的逻辑
        3. 下一层的逻辑 -> 处理下一层的逻辑
        4. 清理 -> 相关的有影响因子的变量需要重置或者其他操作
        def recursion():
            if () return 
            deal_current_level()
            deal_next_level()
            clear_param()

4.  分治 : 将任务拆分成多个小任务， 按照这个操作执行， 
           到不能再分， 就可以开始将小任务处理掉，最后汇总到一起得出结果
    回溯 ： 多层结构， 向下移动的，会保存当前层的状态， 等下一层的执行结果返回
           若是不符合， 则当前层可以恢复原先的状态。


总结：
    捡回了一些大学的知识点，并且巩固加深了。 看了视频，做了题， 有些知识点就是那种感觉： 哦， 原来是这样/ 还能这么想。 尤其是树，递归，分支，回溯。 基本原理不是很难理解， 但是实际应用确实需要经验，需要培养起那种思维， 我觉得这两块地方的知识， 如果掌握了， 对我的技能提升是很大的。